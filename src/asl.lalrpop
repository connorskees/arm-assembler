use std::str::FromStr;
use std::ops::Range;
use crate::{Case, When, WhenClause, Field, WhenBody, CaseClause, BitAccess};

grammar;

match {
    "_",
    "(",
    "=>",
    "!",
    ")",
    r"[0-9]+",
    r"'[01x]+'",
    "+:",
    "case",
    "when",
    ",",
    "of",
    "__decode",
    r"__field \w+",
    r"__encoding \w+ // \w+",
    "A64",
    "{",
    "}",
    "__UNALLOCATED",
    "__UNPREDICTABLE",
    r"[a-zA-Z]\w*",

    // Skip whitespace and comments
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { }, // `// comment`
}


DecimalNum: u8 = {
    r"[0-9]+" => u8::from_str(<>).unwrap(),
};

// BinaryNum: str = {
//     r"'[01x]+'"
// }

Field: Field<'input> = {
    <name:r"__field \w+"> <bit_access:BitAccess> => Field { 
        name: name.trim_start_matches("__field "),
        bit_access
    },
}

Encoding: &'input str = {
   r"__encoding \w+ // \w+" => <>.trim_start_matches("__encoding ")
}

BitAccess: BitAccess = {
    <start:DecimalNum> "+:" <len:DecimalNum> => BitAccess { start, len },
}

Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        Some(e) => {
            v.push(e);
            v
        },
        None => v,
    }
};

CaseClause: CaseClause<'input> = {
    BitAccess => CaseClause::BitAccess(<>),
    r"[a-zA-Z]\w*" => CaseClause::Field(<>),
}

WhenClause: WhenClause<'input> = {
    "_" => WhenClause::Any,
    r"'[01x]+'" => WhenClause::Concrete(<>),
    "!" <a:r"'[01x]+'"> => WhenClause::Not(a)
}

WhenBodySingleLine: WhenBody<'input> = {
    Encoding => {
        let mut split = <>.split(" // ");
        let mut first = split.next().unwrap();
        let mut second = split.next().unwrap();

        if first.starts_with("aarch64") {
            std::mem::swap(&mut first, &mut second);
        }

        WhenBody::Encoding {
            mnemonic: first,
            name: second,
        }
    },
    "__UNALLOCATED" => WhenBody::Unallocated,
    "__UNPREDICTABLE" => WhenBody::Unpredictable,
}

WhenBodyMultiLine: WhenBody<'input> = {
    // <fields:Field*> => WhenBody::Case { fields },
    <fields:Field*> <case:Case> => WhenBody::Case { fields, case: Box::new(case) },
}

When: When<'input> = {
    "when" "(" <clauses:Comma<WhenClause>> ")" "=>" <body:WhenBodySingleLine>  => When { clauses, body },
    "when" "(" <clauses:Comma<WhenClause>> ")" "=>" "{" <body:WhenBodyMultiLine> "}" => When { clauses, body },
}

pub Case: Case<'input> = {
    "__decode" "A64" "{" <a:Case> "}" => a,
    "case" "(" <clauses:Comma<CaseClause>> ")" "of" "{" <when:When+> "}" => Case { clauses, when },
}
